#include <malloc.h>void	*create_new_page(void *collec[], size_t size){	int	i;	i = 0;	while (collec[i] && i < P_MAX)		i++;	if (i == P_MAX)		return (NULL);	collec[i] = mmap(0, size, PROT_READ | PROT_WRITE, MAP_ANON | MAP_PRIVATE, -1, 0);	if (collec[i] == MAP_FAILED)	{		collec[i] = NULL;		return (NULL);	}	collec[i + 1] = NULL;	return (collec[i]);}void	*find_space(void *page[], size_t blocs_needed, size_t max_size){	int	i;	void	*ptr;	size_t		mem;	size_t	size;	i = 0;	while (page[i])	{		mem = 0;		ptr = page[i];		while (mem < max_size)		{			if ((((t_header*)ptr)->used == 1) ||				(!(blocs_needed - sizeof(t_header) == ((t_header*)ptr)->size)					&& (blocs_needed > ((t_header*)ptr)->size)))			{				size = ((t_header*)ptr)->size + sizeof(t_header);				mem += size;				ptr += size;			}			else if (mem + sizeof(t_header) + blocs_needed + sizeof(t_header) > max_size)				mem += sizeof(t_header) + (blocs_needed - ((t_header*)ptr)->size) + sizeof(t_header);			else				return (ptr);		}		i++;	}	return (NULL);}
static t_header	*first_if(t_header *header, int *new_size)
{
	void	*next_header;	void	*nnheader;

	next_header = (char*)header + sizeof(t_header) + ((t_header*)header)->size;
	nnheader = (char*)next_header + sizeof(t_header) + ((t_header*)next_header)->size;
	if (((t_header*)next_header)->used == 0)
		*new_size = ((t_header*)header)->size + sizeof(t_header) + ((t_header*)next_header)->size;	return (header);
}
static t_header *second_if(t_header *header, t_header *next_header, int *new_size){	void	*nnheader;	nnheader = (char*)next_header + sizeof(t_header) + ((t_header*)next_header)->size;	if (((t_header*)header)->used == 0)	{		if (((t_header*)nnheader)->used == 0)			*new_size = ((t_header*)header)->size + sizeof(t_header) + ((t_header*)next_header)->size + sizeof(t_header) + ((t_header*)nnheader)->size;		else			*new_size = ((t_header*)header)->size + sizeof(t_header) + ((t_header*)next_header)->size;		return (header);	}	if (((t_header*)nnheader)->used == 0)		*new_size = ((t_header*)next_header)->size + sizeof(t_header) + ((t_header*)nnheader)->size;	return (next_header);}static	t_header	*find_header_for_free(void	*ptr, void *page, size_t page_max, int *new_size) {	void	*header = page;	void	*eop = page + page_max;	void	*next_header;
	*new_size = 0;	if (ptr >= eop || ptr < page)		return (NULL);	if (header + sizeof(t_header) == ptr)
		return (first_if(header, new_size));	while (header < eop)	{		next_header = header + sizeof(t_header) + ((t_header*)header)->size;		if (next_header >= eop)			return (NULL);		if (next_header + sizeof(t_header) == ptr && ((t_header*)next_header)->used)			return (second_if(header, next_header, new_size));		header = next_header;	}	return (NULL);}t_header	*find_header_tiny_or_small(void	*ptr, t_data *pages, int *new_size){	int				i;	t_header    	*header;	void	**tiny = pages->tiny;	void	**small = pages->small;	i = 0;	while (tiny[i])	{		if ((header = find_header_for_free(ptr, tiny[i], get_t_psize(), new_size)))
			return (header);		i++;	}	i = 0;	while (small[i])	{		if ((header = find_header_for_free(ptr, small[i], get_s_psize(), new_size)))		{			return (header);		}		i++;	}	return (NULL);}